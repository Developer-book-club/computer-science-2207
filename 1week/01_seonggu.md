# Design patterns : Introduction
## 디자인 패턴이란?
 프로그램 설계 시 객체 간 상호 관계 등을 어떻게 구현할지 규약(패턴)을 만들어 놓는 것이다.
**정해진 규약대로 설계**함으로써, 프로그램에서 발생하는 여러 문제들을 회피하고 유지-보수를 용이하게 해준다. 

# 디자인 패턴의 종류
## 싱클톤 패턴
하나의 클래스에 하나의 인스턴스만 생성하고, 이 인스턴스를 여러 모듈에서 공유하는 형태로
주로 데이터 베이스 연결 모듈에 사용된다.    
하나의 인스턴스만 생성하기 때문에 자원(비용)이 적게 소요되는 장점이 있다.
그러나 의존성 문제가 있다. 예를들어 TDD(Test Driven Development)를 할 때 단위 테스트를 진행하게 되면
테스트를 진행할 모듈들이 서로 독립적이어야 하며, 어떤 순서로도 실행이 가능해야 한다. 
하지만 인스턴스를 공유하기 때문에 단위 실행 순서에 따라 인스턴스의 어트리뷰트는 변할 수 있으므로 TDD는 불가하다.

### 의존성 주입
의존성 문제를 해결하기 위해 의존성 주입을 하기도 한다.
의존성 주입이란, Interface 등과 같은 의존성 주입자를 이용해 간접적으로 의존성을 주입하는 것이다.

대표적으로 다음과 같은 세 가지의 의존성 주입 패턴이 있다.
- 생성자 주입 : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입한다.
- Setter를 통한 주입 : 의존성을 입력받는 세터(Setter) 메소드를 만들고 이를 통해 의존성을 주입한다.
- Interface를 통한 주입 : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행시에 이를 통하여 의존성을 주입한다.

이를 통해 모듈을 쉽게 교체할 수 있는 구조가 되어 단위 테스트가 쉬워지는 등 장점이 있으나, 코드의 복잡성이 증가한다.
 **이 개념은 싱글톤 패턴 뿐 아니라 대부분의 디자인 패턴에서 의존성을 줄이기 위해 적용되는 개념**으로 잘 알아두어야 한다.

## 팩토리 패턴
객체를 생성하는 부분을 떼어내 추상화하는 패턴이다.
상속관계에 있는 두 개의 클래스에서 상위 클래스에서는 뼈대를 결정하고, 하위 클래스에서는 객체를 생성하기 위한 세부 내용을 결정한다.
   
의존성 주입과 같은 맥락으로, 상위 클래스가 하위 클래스와 분리되며 느슨한 결합을 가진다.    
상위 클래스에서는 뼈대만 만들어주면 되기 때문에 객체가 실제로 어떻게 생성되는지는 전혀 관여하지 않게 된다.    
객체를 생성 시에 세부사항만 살짝 바꿔줄 일이 있다면 하위 클래스 객체만 수정하면 되기 때문에 유지보수가 쉬워진다.


## 전략 패턴
객체 행위를 바꾸고 싶은 경우, 객체를 직접 수정하지 않고 전략이라 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주어 상호 교체가 가능하게 해준다.   
예를 들어 어떤 상품을 사기 위해 카카오카드나 루나카드로 결제할 수 있다 하자.
이 결제 방법을 전략이라고 하며 아래 예제 코드에서 LUNACardStrategy와  KAKAOCardStrategy에 해당한다.
다른 전략을 사용하더라도 객체 cart는 변경되지 않는다. 이 때문에 전략은 일종의 의존성 주입자라고도 볼 수 있다.
```java
public class HelloWorld{
    public static void main(String []args){
        ShoppingCart cart = new ShoppingCart();
        
        Item A = new Item("kundolA",100);
        Item B = new Item("kundolB",300);
        
        cart.addItem(A);
        cart.addItem(B);
        
        // pay by LUNACard
        cart.pay(new LUNACardStrategy("kundol@example.com", "pukubababo"));
        
        // pay by KAKAOBank
        cart.pay(new KAKAOCardStrategy("Ju hongchul", "123456789", "123", "12/01"));
    }
}
```
## 옵저버 패턴
주체, 대상 객체, 옵저버로 이루어진 패턴이다.    
대상 객체의 상태 변화를 주체가 계속 관찰하면서, 객체에 변화가 생길 때마다 메서드 등을 통해 옵저버들에게 변화를 notify하는 패턴이다.
이 때 주체와 대상 객체를 굳이 분리하지 않고, 하나로 합친 패턴도 있다. 

대표적으로 트위터가 있다. A라는 사람(주체 + 대상 객체)이 글을 올리면(대상 객체의 변화), 팔로우한 사람들(옵저버)에게 알림이 가는 형식이다.

## 프록시 패턴
대상 객체에 접근하기 전, 그 객체에 접근하기 위한 흐름을 가로채면서, 그 객체 앞단에서 인터페이스 역할을 하는 패턴이다.    
대표적으로 node.js에서 nginx을 서버 앞단에 배치하여 프록시 서버로 활용하는 패턴이 있다.

### 프록시(proxy) 객체
프록시 객체는 어떤 대상의 기본적인 동작(속성 접근, 할당, 순회 함수 호출 등)을 가로챌 수 있는 객체를 의미한다.
### 프록시 서버
서버와 클라이언트 사이에서, 클라이언트가 자신을 통해 네트워크에 간접적으로 접속할 수 있는 컴퓨터 시스템이나 응용프로그램을 말한다.

## 이터레이터 패턴
이터레이터 패턴은 이터레이터 객체를 이용해 이터러블한 콜렉션 요소들에 접근하는 패턴이다.
이터러블한 객체기만 하면 하나의 인터페이스로 순회가 가능하다.

## MVC 패턴
![](./../../../assets/images/2022-07-29-design_pattern_images/1659110650240.png)

모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴이다.
어플리케이션의 구성 요소들을 이 세 가지로 나눔으로써, 설계 시 개별 요소에 더 집중할 수 있는 장점을 가진다.    
대표적으로 리엑트 라이브러리가 있다.

### 모델
어플리케이션의 데이터베이스, 상수, 변수 등의 **데이터**를 의미한다.

### 뷰
모델을 구성하는 데이터를 추가/삭제/변경할 수 있는 인터페이스 요소를 나타낸다. 보통은 사용자가 볼 수 있는 GUI를 의미한다.
뷰는 데이터를 따로 저장할 수 있는 기능이 없어야 하며, 모델만 데이터를 따로 가지고 있을 수 있다.    
따라서 **뷰는 엄밀한 의미에서 단순히 모델에 있는 데이터를 보여주기만 할 뿐**이다.
이에 따라 뷰는 모델에 대응되며, 높은 의존성을 가진다.

### 컨트롤러
**모델과 뷰를 이어주는 역할**을 하는 구성요소이다. 사용자가 뷰와 상호작용하면서 모델에 있는 데이터가 변경되도록 로직을 구성한다.
모델과 뷰의 생명 주기도 관리하며 모델이나 뷰의 변경 알림을 받을 경우 이를 해석해 관련된 구성 요소에 전달한다.
컨트롤러는 여러 개를 뷰를 선택할 수 있다. 즉, 1:N 연결 구조이다.


## MVP 패턴
![](./../../../assets/images/2022-07-29-design_pattern_images/1659110633600.png)

MVC 패턴에서 C가 presenter로 변경된 패턴이다.    
이 패턴에서는 Model과 View 분리되어 있고 오직 Presenter를 통해서 상태나 변화를 알려줄 수 있다.     
MVC와 달리 Presenter와 View는 1:1 관계이다.
따라서 View와 모델간 의존성은 줄었으나, presenter와 View의 의존성이 높아지는 문제가 있다.
## MVVM 패턴
![](./../../../assets/images/2022-07-29-design_pattern_images/1659111074030.png)
MVC패턴에서 C가 뷰모델(view model)로 변경된 패턴이다. 뷰모델은 뷰를 더 추상화하여, 커멘드와 데이터 바인딩(화면의 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법)을 가지게 된다.
대표적으로 Vue.js가 있다.


# 질문
- 프로젝트에서 주로 사용해본 디자인 패턴과, 그 패턴을 사용한 이유는?
- 프로그램 설계 시, 의존성을 줄이기 위해 사용할 수 있는 기법을 말하고, 그 기법의 장점과 단점을 얘기해라.
- MVC, MVP, MVVM의 차이에 대해 설명하라.
# Summary

 
# Reference
면접을 위한 CS 전공지식 노트 - 주홍철 지음    
[위키백과-의존성 주입](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85)    
[예제코드](https://github.com/gilbutITbook/080326)


---

# Programming paradigm : Introduction
프로그래밍 패러다임은 프로그래밍을 어떤 원칙으로 할지 정하고, 
이 원칙에 따른 설계 관점을 프로그래머가 갖출 수 있도록 하는 개발 방법론이다.

## 패러다임의 종류
아래와 같이 나뉘나, 이들을 결합한 멀티 패러다임도 있다.
- 선언형
  - 함수형
- 명령형
  - 객체지향형
  - 절차지향형

선언형 프로그래밍은 무엇을(What) 할 것인지에 집중한 패러다임이다.   
반면에 명령형 프로그래밍은 어떻게(HOW) 할 것인지 집중한 패러다임이다.

명령형 - 알고리즘은 명시하고 목표는 명시하지 않는다.   
1. 횡단보도까지 약 99m 이동(성남대로331번길),     
2. 횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,    
3. 횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,   
4. 횡단보도를 이용하여 메르세데스... 방면으로 횡단,   
5. 네이버까지 약 50m 이동(불정로).    

선언형 - 목표를 명시하고 알고리즘을 명시하지 않는다    
출발 : 경기도 성남시 분당구 성남대로 333,    
도착 : 네이버 주소는 경기도 성남시 분당구 불정로 6.
  
# 함수형 패러다임
선언형 프로그래밍의 일종으로, 프로그래밍이 함수의 중첩으로 이루어져 있다.
아래는 함수형 패러다임에 맞춰 최대값을 찾기 위한 예시 코드이다.
```javascript
const ret = [1, 2, 3, 4, 5, 11, 12]
.reduce((max, num) => num > max ? num : max, 0)
console.log(ret) // 12 
```
곧, 작은 순수함수들을 블록처럼 쌓아 로직을 구현한다. 

## 순수 함수
**출력이 입력에만 의존**하는 함수를 의미한다.    
함수형 패러다임에서는 static 변수나 객체 어트리뷰트 등에 의한 상태값이 존재해서는 안되며, 입력과 출력이 1:1 대응되어야 하기 때문에
순수 함수는 이 패러다임을 만족하기 위한 기본 조건이 된다.
```javascript
const pure = (a,b) => {
     return a + b
}
```
## 고차 함수
함수가 함수를 매개변수로 받아 로직을 생성할 수 있는 것을 말한다. 고차함수를 통해 함수를 중첩해 하나의 프로그램으로 설계할 수 있게 된다.
### 일급객체 (first class)
고차 함수를 쓰기 위해서는 프로그래밍 언어에서 아래 조건을 만족해야 하며, 이를 일급 객체 특징을 가진다고 한다.
- 변수나 메서드에 함수를 할당할 수 있다.
- 함수 안에 함수를 매개 변수로 담을 수 있다.
- 함수가 함수를 반환할 수 있다.    

따라서 파이썬은 일급객체 특징을 가진다.

# 객체지향형 패러다임
객체의 집합으로 프로그램의 상호작용을 표현하는 패러다임이다.   
아래는 객체지향 패러다임으로 최대값을 구하는 예시코드이다.
```javascript
const ret = [1, 2, 3, 4, 5, 11, 12]
class List {
    constructor(list) {
        this.list = list
        this.mx = list.reduce((max, num) => num > max ? num : max, 0)
    }
    getMax() {
        return this.mx
    }
}
const a = new List(ret)
console.log(a.getMax()) // 12
```

## 객체 지향 특징
### 추상화
복잡한 시스템에서 공통으로 필요로 하는 핵심적인 기능과 개념을 간추려 표현하는 것이다.
이를 통해 설계의 유연함을 갖출 수 있다. 예를 들어 세부적인 기능 구현은 건너 뛰고 공통적으로 적용되는 뻐대만을 우선 구현할 수도 있다.
#### 자료 추상화
불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다. 자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 한다.      
추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다.    
객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.
### 캡슐화
객체의 속성과 메서드를 하나로 묶고 외부에서 접근하지 못하도록 은닉하는 것을 말한다.

### 상속성
상위 클래스의 특성을 하위 클래스가 이어받아 재사용할 수 있도록 하는 것을 말한다. 이를 통해 계층적인
관계 생성이 가능하며, 유지 보수가 쉬워진다.   
예를 들어 사람이라는 상위 클래스를 만든 후, A라는 사람을 객체로 만들 때, 사람으로서 공통적인 특징은 그대로 상속받고, 고유한 A만의 특성을 따로 정의하여 재사용하는 것이다.

### 다형성
하나의 메서드나 클래스를 다양한 방법으로 동작하도록 하는 것이다.
#### 오버로딩
같은 이름을 가진 메서드를 매개 변수의 유형/개수/타입이 다르게 하여 여러 개 가질 수 있는 것을 말한다.
#### 오버라이딩
상위 클래스에서 상속받은 메서드를 하위 클래스에서 재정의 하는 것을 말한다.

## 객체 지향 설계 원칙
SOLID 원칙이라고 한다.
### 단일 책임 원칙 (S)
모든 클래스는 각각 하나의 책임만을 가진다.
### 개방-폐쇄 원칙 (O)
유지 보수 사항이 생길 경우, 쉽게 확장할 수 있도록 개방하되, 수정 시에는 닫혀야 한다. 
기존 코드를 변경하지 않으면서 수정과 확장이 용이해야 한다고도 표현할 수 있다.
### 리스코프 치환 원칙 (L)
프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
부모의 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가야 한다.
### 인터페이스 분리 원칙 (I)
하나의 인터페이스보다 구체적으로 여러 개 인터페이스를 만들어야 한다.
### 의존 역전 원칙 (D)
상위 계층은 하위 계층위 변화에 대한 구현으로 부터 독립되어야 한다.

# 절차형 패러다임
일이 진행되는 방식으로 코드를 구현하는 것이다. 아래는 절차형 패러다임으로 최대값을 찾는 예시이다.
```javascript
const ret = [1, 2, 3, 4, 5, 11, 12]
let a = 0
for(let i = 0; i < ret.length; i++){
    a = Math.max(ret[i], a)
} 
console.log(a) // 12 
```
# 예상 질문
- 함수형, 객체지향형, 절차형 프로그래밍의 특징과 장단점을 말해라.
- 프로그램의 복잡도가 증가할수록, 일반적으로 절차형 프로그래밍이 객체지향형 프로그래밍보다 유지보수가 어려운 이유를 말해라.
- 파이썬은 대표적인 멀티 패러다임 언어이다. 왜 멀티 패러다임 언어라고 할 수 있는지 각 패러다임 들의 특징을 고려해 예시를 들어라. 언어 자체의 특징 뿐 아니라, 자신이 주로 사용하는 라이브러리 or 오픈소스를 예시로 들어도 좋다.

# Summary

 
# Reference
면접을 위한 CS 전공지식 노트 - 주홍철 지음    
[선언형과 명령형](https://velog.io/@jsj3282/%EB%AA%85%EB%A0%B9%ED%98%95-vs-%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)    
[객체 지향 프로그래밍 - 위키백과](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
[예제코드](https://github.com/gilbutITbook/080326)