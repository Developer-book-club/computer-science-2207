### 4.6 조인의 종류
- 조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것이다. 
- MongoDB에서는 lookup이라는 쿼리로 조인을 처리할 수 있지만 관계형 DB보다 성능이 떨어진다.
- 여러 테이블을 조인하는 작업이 많으면 MongoDB보다는 관계형 데이터베이스를 써야한다.
- 내부 조인: 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 왼쪽 조인: 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- 오른쪽 조인: 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 합집합 조인: 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

#### 4.6.1 내부 조인
- 두 테이블 간애 교집합

```
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

#### 4.6.2 왼쪽 조인
- 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합 생성
- 만약 테이블 B에 일치하는 항목이 없으면 해당 값은 null

```
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

#### 4.6.3 오른쪽 조인
- 오른쪽 조인은 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합 생성
- 만약 테이블 A에 일치하는 항목이 없으면 해당 값은 null

```
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```
#### 4.6.4 합집합 조인
- 합집합 조인(완전 외부 조인)은 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성
- 일치하는 항목이 없으면 누락된 쪽에 null값 포함
```
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```


### 4.7 조인의 원리
- 조인은 조인의 원리를 기반으로 조인 작업이 이루어짐

#### 4.7.1 중첩 루프 조인
- 중첩 루프 조인은 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음
- 예를 들어 't1, t2 테이블을 조인한다'라고 했을 때 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값 반환
```
for each row in t1 matching reference key {
	for each row in t2 matching reference key {
		if row satisfies join conditions, send to client}
}
```
- 블록 중첩 루프 조인: 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인

#### 4.7.2 정렬 병합 조인
- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행
- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인조건으로 범위 비교 연산자가 있을 때 사용

#### 4.7.3 해시 조인
- 해시 테이블을 기반으로 조인
- 두 개의 테이블을 조인할 때 하나의 테이블이 메모리에 온전히 들어가면 중첩 루프 조인보다 도 효율적
- 동등 조인에서만 사용할 수 있음
- MySQL의 해시 조인 단계는 빌드 단계, 프로브 단계로 나뉨
	- 빌드 단계
		- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드
		- persons와 countries라는 테이블을 조인한다고 했을 때 둘 중 바이트가 더 작은 테이블을 기반으로 해서 테이블 빌드
		- 조인에 사용되는 필드가 해시 테이블의 키로 사용됨
	- 프로브 단계
		- 프로브 단계 동안 레코드 읽기를 시작
		- 각 레코드에서 persons.country_id에 일치하는 레코드를 찾아서 결괏값으로 변환
		- 이를 통해 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋음
		- 사용 가능한 메모리양은 시스템 변수 join_buffer_size에 의해 제어. 런타임시 조정 가능


## 5. 자료구조
- 자료규조는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

### 5.1 복잡도
#### 5.1.1 시간 복잡도
빅오 표기법
- 시간 복잡도란 '문제를 해결하는 데 걸리는 시간과 입력의 함수 관계'
- 어떠한 알고리즘 로직이 얼마나 오랜 시간 걸리는지 나타내는 데 쓰이며 보통 빅오 표기법으로 나타냄
- 예를 들어 입력 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 10n² + n 이라고 하면 다음과 같은 코드를 상상가능
```
for (int i = 0; i < 10; i++) {
	for (int j = 0; j < n; j++) {
		for (int k = 0; k < 10; k++) {
			if (true) cout << k << '\n'
			}
		}
}
for (int i = 0; i < n; i++) {
	if (true) cout << i << '\n';
}
```
- 빅오 표기법이란 입력 범위 n을 기준으로 로직이 몇번 반복되는지 나타내는 것. 앞선 코드의 시간복잡도를 빅오 표기법으로 나타내면 O(n²)

시간 복잡도의 존재 이유
- 효율적인 코드로 개선하는데 쓰이는 척도가 됨

시간 복잡도의 속도 비교
- O(n²)보다는 O(n), O(n)보다는 O(1)을 지향해야 함

#### 5.1.2 공간 복잡도
- 공간복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함

#### 5.1.3 자료 구조에서의 시간 복잡도
- 자료 구조를 쓸 때는 시간 복잡도를 잘 생각해야 함

### 5.2 선형 자료 구조
- 선형 자료 구조란 요소가 일렬로 나열되어 있는 자료 구조

#### 5.2.1 연결 리스트
- 연결 리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
- 삽입과 삭제가 O(1) 걸리며 탐색에는 O(n)이 걸림
- prev 포인터와 next 포인터로 앞과 뒤의 노드를 연결시킨 것이 연결리스트
- 연결리스트는 싱글 연결 리스트, 이중 연결 리스트, 원형 이중 연결 리스트가 있음
- 맨 앞에 있는 노드를 헤드라고 함
- 싱글 연결 리스트: next 포인터만 가짐
- 이중 연결 리스트: next 포인터와 prev 포인터를 가짐
- 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것
- 이중연결리스트는 push_front(), push_back(), insert() 등의 함수가 있음

#### 5.2.2 배열
- 같은 타입의 변수들로 이루어져 있고 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용, 순서가 있음
- 탐색에 O(1)이 되어 랜덤 접근 가능, 삽입과 삭제에는 O(n)이 걸림
- 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 탐색을 많이 하는 것을 배열로 하는 것이 좋음
- 배열은 인덱스에 해당하는 원소를 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용
- 랜덤 접근과 순차적 접근
	- 랜덤 접근은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
	- 순차적 접근은 데이터를 저장된 순서대로 검색해야 함
- 배열과 연결 리스트
	- 배열은 상자를 순서대로 나열한 데이터 구조. 몇번째 상자인지 알면 해당 상자의 요소를 끄집어낼 수 있음
	- 연결리스트는 상자를 선으로 연결한 형태의 데이터 구조. 상자 안의 요소를 알기 위해서는 하나씩 내부를 확인해봐야 함
	- 탐색은 배열이 빠르고 연결 리스트는 느림
	- 데이터 추가 및 삭제는 연결리스트가 빠르고 배열은 느림. 배열은 모든 상자를 앞으로 옮겨야 추가가 가능하지만 연결 리스트는 선을 바꿔서 연결해주면 되기 때문

#### 5.2.3 벡터
- 동적으로 요소를 할당할 수 있는 동적 배열
- 컴파일 시점에 개수를 모른다면 벡터를 써야함
- 중복 허용, 순서 있음, 랜덤 접근 가능
- 탐색과 맨 뒤의 요소를 삭제하거나 삽입하는데 O(1) 걸림, 
- 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는 데 O(n)의 시간이 걸림
- 뒤부터 요소를 더하는 push_back(), 맨 뒤부터 지우는 pop_back(), 지우는 erase(), 요소를 찾는 find(), 배열을 초기화하는 clear() 함수가 있음

#### 5.2.4 스택
- 가장 마지막으로 들어간 데이터가 가장 첫번째로 나오는 성질을 가진 자료구조(Last In First Out)
- 재귀적인 함수, 알고리즘, 웹 브라우저 방문 기록 등에 쓰임
- 삽입 및 삭제에 O(1), 탐색에 O(n) 걸림

#### 5.2.5 큐
- 먼저 집어넣은 데이터가 먼저 나오는 성질(First In First Out)을 지닌 자료구조
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸림
- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용
