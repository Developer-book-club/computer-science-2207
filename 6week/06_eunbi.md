### 4. 데이터베이스
### 4.1 데이터베이스의 기본
- 데이터베이스는 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음
- 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS라고 한다
- 데이터베이스는 실시간 접근과 동시 공유가 가능하다

#### 4.1.1 엔터티
- 엔터티는 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
- 약한 엔터티와 강한 엔터티: A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티이고 B는 강한 엔터티

#### 4.1.2 릴레이션
- 릴레이션은 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리
- 릴레이션은 관계형 데이터베이스에서는 테이블, NoSQL 데이터베이스에서는 컬렉션

#### 4.1.3 속성
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
- 예를 들어 '차'라는 엔터티의 속성은 차 넘버, 바퀴 수, 차 색깔, 차종 등이 있음

#### 4.1.4 도메인
- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
- 예를 들어 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여}라는 집합

#### 4.1.5 필드와 레코드
- 예를 들어 회원이라는 엔터티는 member라는 테이블로 속성인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 필드를 가진다
- 테이블에 쌓이는 행의 단위의 데이터를 레코드라고 한다. 레코드를 튜플이라고도 한다.
- 엔터티를 데이터베이스에 넣어 테이블로 만들려면 속성에 맞는 타입을 정의해야 한다.
- 필드는 타입을 갖는다. 타입은 DBMS마다 다르다.
- 숫자타입: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있다.
- 날짜타입: DATE, DATETIME, TIMESTAMP 등이 있다.
- 문자타입: CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 등이 있다.

#### 4.1.6 관계
- 1:1 관계: 예를 들어 유저당 유저 이메일이 한 개씩 있는 경우
- 1:N 관계: 예를 들어 쇼핑몰에서 한 유저당 여러 개의 상품을 장바구니에 넣는 경우. 한 개체가 다른 많은 개체를 포함하는 관계
- N:M 관계: 학생과 강의의 관계를 정의했을 때 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생 포함 가능. 중간에 학생_강의라는 테이블이 끼어 있어서 테이블 두 개를 직접적으로 연결해서 구축하지 않고 1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나눠서 설정

#### 4.1.7 키
- 테이블 간의 관계를 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장리로 기본키, 외래키, 후보기, 슈퍼키, 대체키가 있음
- 유일성은 중복되는 값 없음, 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것
- 기본키 
	- PK 또는 프라이머리키라고 부름. 유일성과 최소성을 만족하는 키
	- 자연키: 유저 테이블을 만들 때 이름, 성별 주민등록번호 중에서 주민등록번호는 중복되지 않음. 이런 식으로 중복된 값들을 제외하며 중복되지 않을 것을 자연스레 뽑다가 나오는 키가 자연키. 언젠가는 변하는 속성을 가짐
	- 인조키: 인위적으로 유저 아이디를 부여하여 고유 식별자가 생겨나는 것. 자연키와는 대조적으로 변하지 않음
- 외래키
	- FK. 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용
	- 외래키는 중복되어도 괜찮다.
- 후보키: 기본키가 될 수 있는 후보들. 유일성과 최소성을 동시에 만족
- 대체키: 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키
- 슈퍼키: 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키


### 4.2 ERD와 정규화 과정
- 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할. 릴레이션 간의 관계들을 정의한 것

#### 4.2.1 ERD의 중요성
- ERD는 시스템의 요구 사항을 기반으로 작성. ERD를 기반으로 데이터베이스를 구축함
- 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용할 수 있지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 있음

#### 4.2.2 예제로 배우는 ERD
#### 4.2.3 정규화 과정
- 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
- 정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정. 정규화된 정도는 정규형으로 표현
- 정규형 원칙: 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 하고 자료의 중복성은 감소해야 하고, 독립적인 관계는 별개의 릴레이션으로 표현해야 하며 각각의 릴레이션은 독리적인 표현이 가능해야 하는 것을 의미
- 제1정규형
	- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값만으로 구성되어야 함
	- 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안된다.
- 제2정규형
	- 릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태
	- 부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
	- 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 함. 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함
- 제3정규형
	- 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태
	- 이행적 함수 종속: A -> B와 B -> C가 존재하면 논리적으로 A -> C가 성립하는데 이때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함
- 보이스/코드 정규형
	- 제3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션 함수 종속 관계에서 모든 결정자가 후보키인 상태
	- 결정자는 함수 종속 관계에서 특정 종속자를 결정짓는 요소, X->Y일 때 X는 결정자, Y는 종속자
- 정규화 과정을 거쳐 테이블을 나눈다고 해서 성능이 100% 좋아지는 것은 아님. 테이블을 나누게 되면 어떤 쿼리는 조인을 해야하는 경우도 발생해서 느려질 수도 있기 때문에 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함


### 4.3 트랜잭션과 무결성
#### 4.3.1 트랜잭션
- 트랜젝션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 데이터베이스에 접근하는 방법은 쿼리이므로 여러 개의 쿼리를 하나로 묶는 단위를 말함
- 특징은 원자성, 일관성, 독립성, 지속성이 있음. ACID 특징이라고 함
- 원자성
	- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
	- 트랜젝션 단위로 여러 로직을 묶을 때 외부 API를 호출하는 것이 있으면 안된다. 있다면 롤백이 일어났을 때 어떻게 해야 할것인지에 대한 해결 방법이 있어야 함
	- 커밋과 롤백
		- 커밋은 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
		- 에러나 이슈 때문에 트랜잭션 전으로 돌려야 할 때 사용하는 것이 롤백
		- 커밋과 롤백 덕에 데이터의 무결성이 보장됨
	- 트랜잭션 전파
		- 트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 하지만 매번 넘겨주기 어렵기 때문에 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것
- 일관성
	- 허용된 방식으로만 데이터를 변경해야 하는 것
	- 데이트베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 한다
- 격리성
	- 트랜잭션 수행 시 서로 끼어들지 못하는 것
	- 격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장
	- 격리 수준은 SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITED가 있음. 위로 갈수록 동시성이 강해지지만 격리성은 약해지고 아래로 갈수록 동시성은 약해지고 격리성은 강해짐
	- 격리 수준에 따라 발생하는 현상
		- 격리 수준에 따라 발생하는 현상은 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 있음
		- 팬텀 리드: 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
		- 반복 가능하지 않은 조회: 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데 그 값이 다른 경우
		- 더티 리드: 반복 가능하지 않은 조회와 유사함. 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은'행의 데이터를 읽을 수 있을 때 발생
	- 격리 수준
		- SERIALIZABLE: 트랜잭션을 순차적으로 진행시키는 것. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음. 매우 엄격한 수준. 교착 상태가 일어날 확률도 많고 가장 성능이 떨어짐
		- REPEATABLE_READ: 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음
		- READ_COMMITTED: 가장 많이 사용되는 격리 수준. 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음. 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음
		- READ_UNCOMMITTED: 가장 낮은 격리 수준. 하나의 트랜잭션이 커밋되기 전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름. 되도록 사용하지 않는 것이 이상적이지만 거대한 양의 데이터를 어림잡아 집계하는데 유용
- 지속성
	- 성공적으로 수행된 트랜재견은 영원히 반영되어야 하는 것
	- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 의미
	- 체크섬, 저널링, 롤백 등의 기능을 제공
	- 체크섬: 중복 검사의 한 형태. 오류 정정을 통해 송신된 자료의 무결성 보호
	- 저널링: 파일 시스템 또는 데이터베이스 시스템에 변경 하상을 반여하기 전에 로깅하는 것

#### 4.3.2 무결성
- 무결셩이란 데이터베이스의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생김
- 무결성의 종류
	- 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않는다
	- 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다
	- 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다
	- NULL 무결성: 특정 송성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건이다.

### 4.4 데이터베이스의 종류
#### 4.4.1 관계형 데이터베이스
- 행과 열을 가지는 표 형식 데이터를 저장하는 형테의 데이터베이스
- SQL이라는 언어를 써서 조작
- MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등이 있음
- MySQL: 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스
- PostgreSQL: 디스크 조각이 차지하는 영역을 회수학 수 있는 장치인 VACUUM이 특징

#### 4.4.2 NoSQL 데이터베이스
- SQL을 사용하지 않는 데이터베이스. MongoDB와 redis 등이 있음
- MongoDB: JSON을 통해 데이터 접근 가능. 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스. 
- redis: 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스. pub/sub 기능을 통해 채팅 시스템, 캐싱 계층 등에 사용

### 4.5 인덱스
#### 4.5.1 인덱스의 필요성
- 인덱스는 데이터를 빠르게 찾을 수 있는 장치
#### 4.5.2 B-트리
- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음. 이는 루트 노드, 리프 노드. 브랜치 노드로 나뉨
- 인덱스가 효율적인 이유와 대수확장성
	- 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문
	- 대수확장성이란 트리 깊이가 노드 수에 비해 매우 느리게 성장하는 것을 의미

#### 4.5.3 인덱스 만드는 방법
- 인덱스를 만드는 방법은 데이터베이스마다 다르다
- MySQL
	- 클러스터형 인덱스와 세컨더리 인덱스가 있다. 
	- 클러스터형 인덱스는 테이블당 하나 설정 가능. primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
	- create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다. 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 더 성능이 좋다
	- 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스이다
- MongoDB
	- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며 해당 키가 기본키로 설정된다.
	- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다

#### 4.5.4 인덱스 최적화 기법
- 인덱스는 비용이다
	- 인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며 관련 읽기 비용이 들게 된다.
	- 또한 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.
	- 그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것이 답은 아니다. 
	- 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것을 비효율적이다
- 항상 테스팅하라
	- 인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 그렇기 때문에 항상 테스팅 하는 것이 중요하다
- 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
	- 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.
	1.  어떠한 값과 같음을 비교하는 == 이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다
	2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다
	3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다
	4. 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다
