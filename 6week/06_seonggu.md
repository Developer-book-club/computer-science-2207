---
layout: single
title: Database - basic
tags: [DB]
categories: database
---
# Introduction
데이터베이스는 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다.

DBMS: 데이터베이스를 제어 관리하는 통합시스템. 데이터베이스 안에 있는 데이터들은
DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 조회, 수정이 가능하다.

데이터베이스는 실시간 접근과 동시에 공유가 가능한데, 이 데이터 베이스를 이루는 기본적인 개념을 알아본다.

# Basic concept
## 엔터티
엔터티는 사람, 장소, 물건 등 여러 속성을 지닌 명사를 의미한다.
ex) 회원 = 엔터디면, 이름, 아이디, 주소 등의 속성을 가진다.

## 약한 엔터티와 강한 엔터티
혼자서 존재하지 못하고 다른 엔터티에 종속적인 엔터티를 약한 엔터티라 한다.
종속적이지 않은 엔터티는 강한 엔터티라고 한다.
예를 들어 건물은 그 자체로 여러 속성을 가지는 강한엔터티로 보고, 건물 안에서만 정의되는
방은 약한 엔터티다.

## 릴레이션
데이터베이스에서 정보를 구분하여 저장하는 기본 단위이다. 
엔터티에 대한 데이터를 데이터베이스는 릴레이션 하나에 저장한다.
- 관계형 데이터베이스에서는 **테이블**이라고 한다.
- NOSQL에서는 **컬렉션**이라고 한다.

## 속성과 도메인
속성은 릴레이션에서 관리하는 구체적이며 고유한 이름 갖는 정보이며,
속성이 가질 수 있는 값의 집합을 도메인이라고 한다.
에를 들어, 성별이란 속성은 {남, 여}의 집합을 도메인으로 갖는다.

## 필드와 레코드
회원이라는 엔터티가 있다고 하면, member라는 테이블에 이름, 아이디 등의 속성을 가질 수 있다.
실제로 **속성들을 테이블의 열로서 name, ID, address로 표현할 수 있는데 이를 필드**라고 한다.
**테이블에 쌓이는 행 단위를 레코드**라고 한다.

## 관계
테이블 간에도 서로 관계가 정의되어 있다. 다음과 같이 관계 화살표를 나타낼 수 있다.  

![](./../../../assets/images/2022-09-03-database_images/1662219055914.png)   
 
0개 또는 1개 이상의 테이블이 관계 되어있을 경우 다음과 같이 표현할 수 있다.    

![](./../../../assets/images/2022-09-03-database_images/1662219102587.png)

## ERD (Entity Relationship Diagram)
데이터 베이스를 구축할 떄 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관게를 정의한 것이다.
구축 시 ERD 예제들을 참고해 청사진을 그려보자..

ERD를 그릴 때 다음의 구성 요소들을 포함해야 한다.
- 엔터티들
- 속성
- 관계
- 액션 (어떻게 엔터티들이 데이터베이스 내에서 정보를 공유하는지를 나타냄)


![img.png](img.png)

## 키
키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별되도록 기준이 되는 **속성**이다.
키를 통해 테이블 간의 관계를 조금 더 명확하게 할 수 있다.
- 유일성 : 중복되는 값이 없는 성질. 학번과 주민번호같은 속성은 중복될 수가 없어 유일성을 가진다.
- 최소성 : 유일성을 만족하는 데 불필요한 필드를 조합하지 않고, 최소 필드만 써서 키를 형성할 수 있는 것.    

![](./../../../assets/images/2022-09-03-database_images/1662219730700.png)

## 키의 종류
- 슈퍼키 : 유일성을 갖춘 키
- 후보키 : 유일성에 최소성까지 갖춘 키
- 기본키 : 테이블에서 지정한 후보키
- 대체키 : 기본키로 지정받지 않은 후보키
- 외래키 : 다른 테이블의 기본키를 그대로 참조하며, 개체와의 관계를 식별하는 데 사용. 중복이 되어도 됨.    
예를 들어 고객 테이블과 주문 테이블이 있을 경우 고객 테이블의 id 속성을 그대로 참조해, 주문 테이블의 user_id 속성에 넣으면, 주문 테이블에서 누가 물건을 주문했는지 알 수 있게 된다.

후보키에서 기본키로 선택하는 기준은 보통 다음과 같다.
- **널 값을 가질 수 없는** 후보키
- 값이 **자주 변경되지 않는** 후보키
- **단순한** 후보키


# Reference
면접을 위한 CS 전공지식 노트 - 주홍철 지음         
[데이터베이스-관계](https://doorbw.tistory.com/228)       
[ERD 보조 설명](https://www.techtarget.com/searchdatamanagement/definition/entity-relationship-diagram-ERD)


---
layout: single
title: Database - 정규화
tags: [DB, NF]
categories: database
---
# Introduction
관계형 데이터베이스의 설계에서 **중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화**라고 한다.    
아래와 같은 장점을 가진다.
- 릴레이션 간의 잘못된 종속 관계로 데이터베이스 이상 현상이 일어나 이를 해결함.
- 저장 공간을 효율적으로 사용.

아래의 원칙을 가진다.
- 정규화되어도 같은 의미를 표현해야 한다.
- 자료의 중복성은 감소해야 한다.
- 독립적인 관계는 별개의 릴레이션으로 표현한다.
- 각 릴레이션은 독립적인 표현이 가능해야 한다.

비공식적으로 **관계형 데이터베이스 테이블이 3NF화가 되었으면 정규화되었다라고 한다.** 3NF 테이블의 대부분이 삽입, 변경, 삭제 이상이 없으며, 3NF 테이블의 대부분이 BCNF, 4NF, 5NF이다

그러나, 성능적인 이유로 항상 정규화를 진행하지는 않는다.

# 데이터베이스 이상 현상
충분히 정규화 되지 않은 테이블은 아래와 같은 특성들이 있다

## 갱신 이상
같아야 하는 정보가 복수 개의 행에서 표현되면, 갱신 시 논리적인 모순을 초래할 수 있다.   
아래 예시에서 Employee 519는 다른 레코드에서 다른 주소를 가지고 있다.    

![](./../../../assets/images/2022-09-03-database_NF_images/1662223299676.png)

## 삽입 이상
테이블 조건(식별 필드에 NULL 삽입 금지 등)에 따라 레코드 삽입이 불가능한 경우이다.
아래 예시에서 신입 교수인 Dr. Newsome은 아직 수업을 배정받지 않았다는 이유로 교수 정보를 관리하는 이 테이블에 Newsome 교수 레코드를 삽입할 수가 없다.   
![](./../../../assets/images/2022-09-03-database_NF_images/1662223309680.png)

## 삭제 이상
어떤 정보를 삭제하는데, 삭제되면 안 되는 다른 사실이 함께 삭제되는 현상이 있을 수 있다.   
ENG-206 수업이 끝나 해당 레코드를 삭제하면, Dr. Giddens 교수의 모든 정보가 삭제된다.
![](./../../../assets/images/2022-09-03-database_NF_images/1662223314436.png)


# 제1정규형
릴에이션의 **모든 도메인이** 더 이상 분해가 불가능한 **원자값으로만 구성**되어야 한다.   
아래 예시에서, **두 개 이상의 값을 가지는 반복집합이 있어서는 안된다.**   

|유저ID|수강명|학점|
|-----|--------|------|
| 차현 | {C, Python} | {A0, B-} |
| 종석 | {Java, DB} | {A+, C+} |

아래와 같이 수정하여 제1정규형을 만족할 수 있다.

|유저ID|수강명|학점|
|-----|---|---|
| 차현 | C | A0 |
| 차현 | Python | B |
| 종석 | Java | A+ |
| 종석 | DB | C+ |

# 제2정규형
제1정규형을 만족하고 **부분 함수의 종속성을 제거**해야 한다.
- 부분 함수의 종속성 : 기본키가 복합키일 경우, 복합키의 특정 컬럼에만 종속된 속성이 있음.   
부분 함수의 종속성이 제거되면, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적이다.   

아래 예시에서는 모든 속성이 중복된 값을 가지므로 복합키를 기본키로 가져야 한다.
{유저ID, 수강명}을 기본키로 할 수 있다. 그러나, 이 경우 유저ID로만 번호 속성이 결정되어 부분 함수의 종속성을 가지게 된다.

| 번호  | 유저ID |수강명|학점|
|-----|------|---|---|
| 1   | 차현   | C      | A0 |
| 1   | 차현   | Python | B |
| 2   | 종석   | Java | A+ |
| 2| 종석   | DB   | C+ |

따라서 다음과 같이 릴레이션을 2개로 분리해 부분 함수의 종속성을 제거할 수 있다. 

| 번호 | 유저ID |
|-----|-----|
| 1   | 차현  | 
| 2   | 종석  |

| 유저ID |수강명|학점|
|------|---|---|
| 차현   | C      | A0 |
| 차현   | Python | B |
| 종석   | Java | A+ |
| 종석   | DB   | C+ |

# 제3정규형
제2정규형을 만족하면서, 기본키가 아닌 모든 속성이 **이행적 함수 종속을 만족하지 않는 상태**이다.
이행적 함수 종속: A->B, B->C가 존재하면, 논리적으로 A->C가 성립되며, 즉 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 할 수 있다.

아래 예시에서 유저 ID에 의해 할인율이 정해지므로 이행적 함수 종속 상태다.

| 유저ID | 회원등급| 할인율 |
|-----|-----|-----|
| 1   | 골드 | 10% | 
| 2   | 실버 | 5%  |
| 3   | 플래티넘 | 15% |

다음과 같이 릴레이션을 분해하여 이행적 함수 종속 제거가 가능하다.

| 유저ID | 회원등급| 
|-----|-----|
| 1   | 골드 |
| 2   | 실버 | 
| 3   | 플래티넘 |

 | 회원등급| 할인율 |
|-----|-----|
 | 골드 | 10% | 
 | 실버 | 5%  |
 | 플래티넘 | 15% |

# 보이스/코드 정규형 (BCNF)
제3정규형을 만족하고, **모든 결정자가 후보키인 상태**를 말한다.
- 결정자 : **함수 종속 관계에서 X->Y일 때 X는 결정자, Y는 종속자이다**. 

예를 들어 요구 사항이 다음과 같다.
- 각 수강명에 대해 한 학생은 한 강사의 강의만 수강한다.
- 각 강사는 한 수강명만 담당한다.
- 한 수강명은 여러 강사가 담당할 수 있다.

다음과 같이 릴레이션을 구성했다.

| 학번    | 수강명|강사|
|-------|----|---|
| 12010 | 코딩테스트 | 큰돌|
| 12010 | MEVN | 재엽|
| 12011 | 코딩테스트 | 큰돌|
| 12011 | MEVN |가영|

이 때 {학번, 수강명} 또는 {학번, 강사}가 후보키가 된다.   
이 때, 범석이란 강사가 JAVA라는 수강명을 담당하기로 결정되어 레코드에 삽입할 경우, 학생이 정해지지 않아 학번이 NULL이 될 수 있다.


함수 종속 다이어그램을 그리면 다음과 같다.

![](./../../../assets/images/2022-09-03-database_NF_images/1662225842650.png)

즉 강사 속성은 수강명을 결정하는 결정자이나, 후보키가 아니므로 이 강사 속성은 분리되어야 한다.

다음과 같이 릴레이션을 분리할 수 있다.

| 학번 |강사|
|---|---|
| 12010 | 큰돌|
| 12010 | 재엽|
| 12011 | 큰돌|
| 12011 |가영|

| 수강명   |강사|
|-------|---|
| 코딩테스트 | 큰돌|
| MEVN  | 재엽|
| MEVN  |가영|
| JAVA  |범석|

# Reference
면접을 위한 CS 전공지식 노트 - 주홍철 지음         
[정규화-위키백과](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94)


---
layout: single
title: Database - 트랜잭션과 무결성
tags: [DB, Transaction, Integrity]
categories: database
---
# Introduction
데이터베이스를 구성한 뒤, 효율적인 처리와 이상 현상 제거를 위해 정규화를 진행하고 본격적으로 데이터베이스를 사용할 준비가 되었다고 하자.   
데이터베이스에 접근하기 위해서는 쿼리를 사용하여야 한다. 실제로 의미있는 작업을 하기 위해서는
여러 개의 쿼리를 묶어서 데이터에 접근/조작하게 된다.    
**트랜잭션은 여러 개의 쿼리들을 하나로 묶는 단위이며, 하나의 논리적 기능을 수행하기 위한 작업의 단위로 볼 수 있다.**

트랜잭션 도중 시스템 장애로 인해 작업을 온전히 하지 못할 수 있다. 이로 인해 발생할 에러 들에 대해 알아보고, 이를 회피하기 위해 트랜젝션이 가져야 할 특징들에 대해 알아본다.

# ACID
트랜잭션이 가져야 할 특징으로 원자성, 일관성, 독립성, 지속성을 의미한다.

## 원자성
"All or nothing"으로 요약할 수 있다. 트랜잭션과 관련된 일이 모두 수행되거나 되지 않음을 보장하는 것이다.
트랜잭션을 커밋했는 데 문제가 발생해 롤백할 경우 모두 수행되지 않음이 보장되어야 한다.

예를 들어 100만원을 가진 규철이 0원 가진 규영이에게 50만원을 이체한다고 하면 다음과 같은 쿼리들이 수행되어야 한다.
1. 규철의 잔고를 조회.
2. 규철의 잔고에서 50만원 인출.
3. 규영의 잔고에 50만원 입금.

만약 2의 과정에서 시스템 장애로 트랜잭션이 중단된 뒤 특별한 조치를 취하지 않는다면, 규철의 잔고에서 50만원이 그냥 날라간 것이기 때문에 문제가 된다.
즉 이 작업이 도중 취소/중단될 경우 모든 operation은 취소되어야 한다.


### 커밋과 롤백
- 커밋 : 여러 쿼리가 성공적으로 처리되었음을 확정하는 명령어
- 롤백 : 에러나 이슈로 트랜잭션 전으로 돌리는 것

## 일관성
허용된 방식으로만 데이터를 변경해야 한다. 예를 들어 규철의 잔고보다 더 많은 돈을 인출하려고 하면 일관성의 원칙에 위배된다.


## 격리성
트랜잭션 수행 시, 다른 트랜잭션이 끼어들지 못하게 하는 것이다.
복수의 트랜잭션이 병렬로 수행될 경우에도 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동해야 한다.

### 격리 수준에 따른 이상 현상
- 팬텀 리드 : 한 트랜잭션 내에서 동일한 쿼리를 보낼 때, 조회 결과가 다른 경우    
![](./../../../assets/images/2022-09-03-database_transaction_images/1662228293334.png)     

- 반복 가능하지 않은 조회 : 한 트랜잭션 내에 같은 행에 두 번 이상 조회가 발생했는데, **그 값이 다른 경우**
팬텀 리드는 다른 행이 선택될 수 있으나, 반복 가능하지 않는 조회는 행값이 달라질 수 있다. 
- ![](./../../../assets/images/2022-09-03-database_transaction_images/1662228270005.png)    

- 더티 리드 : 한 트랜잭션이 실행 중일 때, 다른 트랜잭션에 의해 수정되었으나 '아직 커밋되지 않은' 행의 데이터를 읽을 수 있는 경우.    
![](./../../../assets/images/2022-09-03-database_transaction_images/1662228251483.png)   

### 격리 수준
READ UNCOMMITTED로 갈수록 동시성은 높으나, 격리성이 낮다.
![](./../../../assets/images/2022-09-03-database_transaction_images/1662228584357.png)

- READ UNCOMMITTED: 각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부와 상관 없이 다른 트랜잭션에서 보여지게 된다.
- READ COMMITTED: 다른 트랜잭션이 커밋하지 않은 정보를 읽을 수 없다. 가장 많이 선택되는 격리 수준이다. 읽는 것만 그렇고, 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 도중에 수정할 수 있다.
- REPEATABLE READ : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션에서 수정할 수 없다.
- SERIALIZABLE  : 병렬 수행을 허용하지 않고, 트랜잭션을 순차적으로 수행시킨다.

## 지속성
성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다. 즉, 시스템 장애가 발생해도 원래 상태로 복구할 수 있어야 한다.

- 체크섬 : 오류 정정을 통해 송신된 자료의 무결성을 보호하는 방법
- 저널링 : 커밋 결과를 반영하기 전에 변경 사항에 대한 로그를 남기는 것

## 무결성
데이터의 정확성, 일관성, 유효성을 유지하는 것


| 이름       | 설명                                                     |
|----------|--------------------------------------------------------|
| 개체 무결성   | 기본키로 선택된 필드는 빈 값을 허용하지 않음                              |
| 참조 무결성   | 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 가져야 함               | 
| 고유 무결성   | 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 속성 값은 모두 고유한 값을 가짐    | 
| NULL 무결성 | 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 올 수 없음 | 
# Reference
면접을 위한 CS 전공지식 노트 - 주홍철 지음         
[MySQL 트랜잭션 격리 수준](https://steady-coding.tistory.com/562)